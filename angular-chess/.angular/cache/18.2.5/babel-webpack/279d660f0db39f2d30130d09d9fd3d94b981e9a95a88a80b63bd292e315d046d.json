{"ast":null,"code":"import { ChessBase } from \"./chess-base.\";\nimport { Figure } from \"./chess-figure\";\nexport class FigurePawn extends Figure {\n  constructor(color) {\n    super('pawn', color, 1, 2);\n  }\n  isStepPossible(step) {\n    let _retVal = false;\n    if (this.isCoordsNotEquals(step)) {\n      if (this.isDistancePossible(step)) {\n        if (this.isForwardStep(step)) {\n          if (this.isStepNotBlocked(step)) {\n            if (this.isOneCellStep(step) || this.isTwoCellStepFromOrig(step)) {\n              if (this.isLinearStep(step) && this.isStepNotBlockedByEnemy(step) || this.isDiagonalStep(step) && this.isPunchOrEnPassant(step)) {\n                _retVal = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return _retVal;\n  }\n  isForwardStep(step) {\n    let _retVal = false;\n    if (this.color === 'white' && step.from.y > step.to.y || this.color === 'black' && step.from.y < step.to.y) {\n      _retVal = true;\n    }\n    return _retVal;\n  }\n  isTwoCellStepFromOrig(step) {\n    return this.isLinearStep(step) && this.isOrigPosition(step) && this.isTwoCellStep(step);\n  }\n  isPunchOrEnPassant(step) {\n    return this.isPunch(step) || this.isEnPassant(step);\n  }\n  isPunch(step) {\n    let _retVal = false;\n    const base = ChessBase.instance;\n    const fig = base.getFigure(step.to.x, step.to.y);\n    if (fig && fig.color !== this.color) {\n      if (fig.name !== 'king' || base.isHitEnemyKingCanBeTested) {\n        _retVal = true;\n      }\n    }\n    return _retVal;\n  }\n  isEnPassant(step) {\n    let _retVal = false;\n    const base = ChessBase.instance;\n    const fig = base.getFigure(step.to.x, step.to.y);\n    if (!fig && base.enPassant) {\n      if (base.enPassant.to.x === step.to.x && base.enPassant.to.y === step.to.y) {\n        _retVal = true;\n      }\n    }\n    return _retVal;\n  }\n  isMovedToEnPassantPosition(step) {\n    let _retVal = false;\n    if (this.isTwoCellStepFromOrig(step)) {\n      const offsetY = step.to.y > step.from.y ? 1 : -1;\n      const base = ChessBase.instance;\n      const fig = base.getFigure(step.to.x, step.to.y + offsetY);\n      if (fig && fig.color !== this.color) {\n        const figInLeft = step.to.x > 0 ? base.getFigure(step.to.x - 1, step.to.y) : null;\n        const figInRight = step.to.x < 7 ? base.getFigure(step.to.x + 1, step.to.y) : null;\n        if (figInLeft && figInLeft.color !== this.color || figInRight && figInRight.color !== this.color) {\n          _retVal = true;\n        }\n      }\n    }\n    return _retVal;\n  }\n  isTwoCellStep(step) {\n    return this.color === 'white' && step.from.y - step.to.y === 2 || this.color === 'black' && step.to.y - step.from.y === 2;\n  }\n  isOrigPosition(step) {\n    return this.color === 'white' && step.from.y === 6 || this.color === 'black' && step.from.y === 1;\n  }\n  isStepNotBlockedByEnemy(step) {\n    let _retVal = true;\n    const fig = ChessBase.instance.getFigure(step.to.x, step.to.y);\n    if (fig && fig.color !== this.color) {\n      _retVal = false;\n    }\n    return _retVal;\n  }\n}","map":{"version":3,"names":["ChessBase","Figure","FigurePawn","constructor","color","isStepPossible","step","_retVal","isCoordsNotEquals","isDistancePossible","isForwardStep","isStepNotBlocked","isOneCellStep","isTwoCellStepFromOrig","isLinearStep","isStepNotBlockedByEnemy","isDiagonalStep","isPunchOrEnPassant","from","y","to","isOrigPosition","isTwoCellStep","isPunch","isEnPassant","base","instance","fig","getFigure","x","name","isHitEnemyKingCanBeTested","enPassant","isMovedToEnPassantPosition","offsetY","figInLeft","figInRight"],"sources":["/Users/sumegizoltan/github/_uj/AngularChess/angular-chess/src/app/chess/chess-figure-pawn.ts"],"sourcesContent":["import { ChessBase } from \"./chess-base.\";\nimport { Figure } from \"./chess-figure\";\n\nexport class FigurePawn extends Figure implements IFigure {\n    \n    constructor(color: string){\n        super('pawn', color, 1, 2);\n    }\n\n    isStepPossible(step: IStep): boolean {\n        let _retVal = false;\n        \n        if (this.isCoordsNotEquals(step)) {\n            if (this.isDistancePossible(step)) {\n                if (this.isForwardStep(step)) {\n                    if (this.isStepNotBlocked(step)) { \n                        if (this.isOneCellStep(step) || this.isTwoCellStepFromOrig(step)) {\n                            if ((this.isLinearStep(step) && this.isStepNotBlockedByEnemy(step)) \n                                || (this.isDiagonalStep(step) && this.isPunchOrEnPassant(step))) { \n                                _retVal = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return _retVal;\n    }\n\n    private isForwardStep(step: IStep): boolean {\n        let _retVal = false;\n        \n        if ((this.color === 'white' && step.from!.y > step.to!.y)\n                || (this.color === 'black' && step.from!.y < step.to!.y)) {\n            _retVal = true;\n        }\n\n        return _retVal;\n    }\n\n    private isTwoCellStepFromOrig(step: IStep): boolean {\n        \n        return (this.isLinearStep(step) && this.isOrigPosition(step) && this.isTwoCellStep(step));\n    }\n\n    private isPunchOrEnPassant(step: IStep): boolean {\n\n        return (this.isPunch(step) || this.isEnPassant(step));\n    }\n\n    private isPunch(step: IStep): boolean {\n        let _retVal = false;\n        const base = ChessBase.instance;\n        const fig = base.getFigure(step.to!.x, step.to!.y);\n\n        if (fig && fig.color !== this.color) {\n            if (fig.name !== 'king' || base.isHitEnemyKingCanBeTested) {\n                _retVal = true;\n            }\n        }\n\n        return _retVal;\n    }\n\n    private isEnPassant(step: IStep): boolean {\n        let _retVal = false;\n        const base = ChessBase.instance;\n        const fig = base.getFigure(step.to!.x, step.to!.y);\n\n        if (!fig && base.enPassant) {\n            if (base.enPassant.to.x === step.to!.x && base.enPassant.to.y === step.to!.y) {\n                _retVal = true;\n            }\n        }\n\n        return _retVal;\n    }\n\n    isMovedToEnPassantPosition(step: IStep): boolean {\n        let _retVal = false;\n\n        if (this.isTwoCellStepFromOrig(step)) {\n            const offsetY = (step.to!.y > step.from!.y) ? 1 : -1;\n            const base = ChessBase.instance;\n            const fig = base.getFigure(step.to!.x, step.to!.y + offsetY);\n\n            if (fig && fig.color !== this.color) {\n                const figInLeft = (step.to!.x > 0) ? base.getFigure(step.to!.x - 1, step.to!.y) : null;\n                const figInRight = (step.to!.x < 7) ? base.getFigure(step.to!.x + 1, step.to!.y) : null;\n\n                if ((figInLeft && figInLeft.color !== this.color)\n                        || (figInRight && figInRight.color !== this.color)) {\n                    _retVal = true;\n                }\n            }\n        }\n\n        return _retVal;\n    }\n\n    private isTwoCellStep(step: IStep): boolean {\n        return ((this.color === 'white' && (step.from!.y - step.to!.y) === 2)\n                || (this.color === 'black' && (step.to!.y - step.from!.y) === 2));\n    }\n\n    private isOrigPosition(step: IStep): boolean {\n        return (this.color === 'white' && step.from!.y === 6) \n                || (this.color === 'black' && step.from!.y === 1);\n    }\n\n    private isStepNotBlockedByEnemy(step: IStep): boolean {\n        let _retVal = true;\n        const fig = ChessBase.instance.getFigure(step.to!.x, step.to!.y);\n\n        if (fig && fig.color !== this.color) {\n            _retVal = false;\n        }\n        \n        return _retVal;\n    }\n}"],"mappings":"AAAA,SAASA,SAAS,QAAQ,eAAe;AACzC,SAASC,MAAM,QAAQ,gBAAgB;AAEvC,OAAM,MAAOC,UAAW,SAAQD,MAAM;EAElCE,YAAYC,KAAa;IACrB,KAAK,CAAC,MAAM,EAAEA,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;EAC9B;EAEAC,cAAcA,CAACC,IAAW;IACtB,IAAIC,OAAO,GAAG,KAAK;IAEnB,IAAI,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC,EAAE;MAC9B,IAAI,IAAI,CAACG,kBAAkB,CAACH,IAAI,CAAC,EAAE;QAC/B,IAAI,IAAI,CAACI,aAAa,CAACJ,IAAI,CAAC,EAAE;UAC1B,IAAI,IAAI,CAACK,gBAAgB,CAACL,IAAI,CAAC,EAAE;YAC7B,IAAI,IAAI,CAACM,aAAa,CAACN,IAAI,CAAC,IAAI,IAAI,CAACO,qBAAqB,CAACP,IAAI,CAAC,EAAE;cAC9D,IAAK,IAAI,CAACQ,YAAY,CAACR,IAAI,CAAC,IAAI,IAAI,CAACS,uBAAuB,CAACT,IAAI,CAAC,IAC1D,IAAI,CAACU,cAAc,CAACV,IAAI,CAAC,IAAI,IAAI,CAACW,kBAAkB,CAACX,IAAI,CAAE,EAAE;gBACjEC,OAAO,GAAG,IAAI;cAClB;YACJ;UACJ;QACJ;MACJ;IACJ;IAEA,OAAOA,OAAO;EAClB;EAEQG,aAAaA,CAACJ,IAAW;IAC7B,IAAIC,OAAO,GAAG,KAAK;IAEnB,IAAK,IAAI,CAACH,KAAK,KAAK,OAAO,IAAIE,IAAI,CAACY,IAAK,CAACC,CAAC,GAAGb,IAAI,CAACc,EAAG,CAACD,CAAC,IAC5C,IAAI,CAACf,KAAK,KAAK,OAAO,IAAIE,IAAI,CAACY,IAAK,CAACC,CAAC,GAAGb,IAAI,CAACc,EAAG,CAACD,CAAE,EAAE;MAC9DZ,OAAO,GAAG,IAAI;IAClB;IAEA,OAAOA,OAAO;EAClB;EAEQM,qBAAqBA,CAACP,IAAW;IAErC,OAAQ,IAAI,CAACQ,YAAY,CAACR,IAAI,CAAC,IAAI,IAAI,CAACe,cAAc,CAACf,IAAI,CAAC,IAAI,IAAI,CAACgB,aAAa,CAAChB,IAAI,CAAC;EAC5F;EAEQW,kBAAkBA,CAACX,IAAW;IAElC,OAAQ,IAAI,CAACiB,OAAO,CAACjB,IAAI,CAAC,IAAI,IAAI,CAACkB,WAAW,CAAClB,IAAI,CAAC;EACxD;EAEQiB,OAAOA,CAACjB,IAAW;IACvB,IAAIC,OAAO,GAAG,KAAK;IACnB,MAAMkB,IAAI,GAAGzB,SAAS,CAAC0B,QAAQ;IAC/B,MAAMC,GAAG,GAAGF,IAAI,CAACG,SAAS,CAACtB,IAAI,CAACc,EAAG,CAACS,CAAC,EAAEvB,IAAI,CAACc,EAAG,CAACD,CAAC,CAAC;IAElD,IAAIQ,GAAG,IAAIA,GAAG,CAACvB,KAAK,KAAK,IAAI,CAACA,KAAK,EAAE;MACjC,IAAIuB,GAAG,CAACG,IAAI,KAAK,MAAM,IAAIL,IAAI,CAACM,yBAAyB,EAAE;QACvDxB,OAAO,GAAG,IAAI;MAClB;IACJ;IAEA,OAAOA,OAAO;EAClB;EAEQiB,WAAWA,CAAClB,IAAW;IAC3B,IAAIC,OAAO,GAAG,KAAK;IACnB,MAAMkB,IAAI,GAAGzB,SAAS,CAAC0B,QAAQ;IAC/B,MAAMC,GAAG,GAAGF,IAAI,CAACG,SAAS,CAACtB,IAAI,CAACc,EAAG,CAACS,CAAC,EAAEvB,IAAI,CAACc,EAAG,CAACD,CAAC,CAAC;IAElD,IAAI,CAACQ,GAAG,IAAIF,IAAI,CAACO,SAAS,EAAE;MACxB,IAAIP,IAAI,CAACO,SAAS,CAACZ,EAAE,CAACS,CAAC,KAAKvB,IAAI,CAACc,EAAG,CAACS,CAAC,IAAIJ,IAAI,CAACO,SAAS,CAACZ,EAAE,CAACD,CAAC,KAAKb,IAAI,CAACc,EAAG,CAACD,CAAC,EAAE;QAC1EZ,OAAO,GAAG,IAAI;MAClB;IACJ;IAEA,OAAOA,OAAO;EAClB;EAEA0B,0BAA0BA,CAAC3B,IAAW;IAClC,IAAIC,OAAO,GAAG,KAAK;IAEnB,IAAI,IAAI,CAACM,qBAAqB,CAACP,IAAI,CAAC,EAAE;MAClC,MAAM4B,OAAO,GAAI5B,IAAI,CAACc,EAAG,CAACD,CAAC,GAAGb,IAAI,CAACY,IAAK,CAACC,CAAC,GAAI,CAAC,GAAG,CAAC,CAAC;MACpD,MAAMM,IAAI,GAAGzB,SAAS,CAAC0B,QAAQ;MAC/B,MAAMC,GAAG,GAAGF,IAAI,CAACG,SAAS,CAACtB,IAAI,CAACc,EAAG,CAACS,CAAC,EAAEvB,IAAI,CAACc,EAAG,CAACD,CAAC,GAAGe,OAAO,CAAC;MAE5D,IAAIP,GAAG,IAAIA,GAAG,CAACvB,KAAK,KAAK,IAAI,CAACA,KAAK,EAAE;QACjC,MAAM+B,SAAS,GAAI7B,IAAI,CAACc,EAAG,CAACS,CAAC,GAAG,CAAC,GAAIJ,IAAI,CAACG,SAAS,CAACtB,IAAI,CAACc,EAAG,CAACS,CAAC,GAAG,CAAC,EAAEvB,IAAI,CAACc,EAAG,CAACD,CAAC,CAAC,GAAG,IAAI;QACtF,MAAMiB,UAAU,GAAI9B,IAAI,CAACc,EAAG,CAACS,CAAC,GAAG,CAAC,GAAIJ,IAAI,CAACG,SAAS,CAACtB,IAAI,CAACc,EAAG,CAACS,CAAC,GAAG,CAAC,EAAEvB,IAAI,CAACc,EAAG,CAACD,CAAC,CAAC,GAAG,IAAI;QAEvF,IAAKgB,SAAS,IAAIA,SAAS,CAAC/B,KAAK,KAAK,IAAI,CAACA,KAAK,IACpCgC,UAAU,IAAIA,UAAU,CAAChC,KAAK,KAAK,IAAI,CAACA,KAAM,EAAE;UACxDG,OAAO,GAAG,IAAI;QAClB;MACJ;IACJ;IAEA,OAAOA,OAAO;EAClB;EAEQe,aAAaA,CAAChB,IAAW;IAC7B,OAAS,IAAI,CAACF,KAAK,KAAK,OAAO,IAAKE,IAAI,CAACY,IAAK,CAACC,CAAC,GAAGb,IAAI,CAACc,EAAG,CAACD,CAAC,KAAM,CAAC,IACxD,IAAI,CAACf,KAAK,KAAK,OAAO,IAAKE,IAAI,CAACc,EAAG,CAACD,CAAC,GAAGb,IAAI,CAACY,IAAK,CAACC,CAAC,KAAM,CAAE;EAC5E;EAEQE,cAAcA,CAACf,IAAW;IAC9B,OAAQ,IAAI,CAACF,KAAK,KAAK,OAAO,IAAIE,IAAI,CAACY,IAAK,CAACC,CAAC,KAAK,CAAC,IACxC,IAAI,CAACf,KAAK,KAAK,OAAO,IAAIE,IAAI,CAACY,IAAK,CAACC,CAAC,KAAK,CAAE;EAC7D;EAEQJ,uBAAuBA,CAACT,IAAW;IACvC,IAAIC,OAAO,GAAG,IAAI;IAClB,MAAMoB,GAAG,GAAG3B,SAAS,CAAC0B,QAAQ,CAACE,SAAS,CAACtB,IAAI,CAACc,EAAG,CAACS,CAAC,EAAEvB,IAAI,CAACc,EAAG,CAACD,CAAC,CAAC;IAEhE,IAAIQ,GAAG,IAAIA,GAAG,CAACvB,KAAK,KAAK,IAAI,CAACA,KAAK,EAAE;MACjCG,OAAO,GAAG,KAAK;IACnB;IAEA,OAAOA,OAAO;EAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}