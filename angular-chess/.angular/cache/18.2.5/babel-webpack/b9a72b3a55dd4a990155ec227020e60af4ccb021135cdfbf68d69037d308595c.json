{"ast":null,"code":"import { ChessBase } from \"./chess-base.\";\nexport class Figure {\n  constructor(name, color, maxX, maxY) {\n    this.name = name;\n    this.color = color;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  isDistancePossible(step) {\n    let _retVal = false;\n    if (Math.abs(step.to.x - step.from.x) <= this.maxX && Math.abs(step.to.y - step.from.y) <= this.maxY) {\n      _retVal = true;\n    }\n    return _retVal;\n  }\n  isStepNotBlocked(step) {\n    let _retVal = true;\n    if (!this.isCellToNotBlockedBySameFigure(step) || !this.isCellToNotBlockedByEnemyKing(step)) {\n      _retVal = false;\n    } else {\n      const increaseX = this.getIncreaseX(step);\n      const increaseY = this.getIncreaseY(step);\n      let x = step.from.x;\n      let y = step.from.y;\n      let fig = null;\n      let processNext = true;\n      const base = ChessBase.instance;\n      while (_retVal && processNext) {\n        x += increaseX;\n        y += increaseY;\n        if (step.to.x === x && step.to.y === y) {\n          processNext = false;\n        } else {\n          fig = base.getFigure(x, y);\n          if (fig) {\n            processNext = false;\n            _retVal = false;\n          }\n        }\n      }\n    }\n    return _retVal;\n  }\n  getIncreaseX(step) {\n    return step.to.x > step.from.x ? 1 : step.to.x === step.from.x ? 0 : -1;\n  }\n  getIncreaseY(step) {\n    return step.to.y > step.from.y ? 1 : step.to.y === step.from.y ? 0 : -1;\n  }\n  isCellToNotBlockedBySameFigure(step) {\n    let _retVal = true;\n    const figTo = ChessBase.instance.getFigure(step.to.x, step.to.y);\n    if (figTo && figTo.color === this.color) {\n      _retVal = false;\n    }\n    return _retVal;\n  }\n  isCellToNotBlockedByEnemyKing(step) {\n    let _retVal = true;\n    const base = ChessBase.instance;\n    if (!(base.isHitEnemyKingCanBeTested || this.name === 'pawn')) {\n      const figTo = base.getFigure(step.to.x, step.to.y);\n      if (figTo && figTo.color !== this.color && figTo.name === 'king') {\n        _retVal = false;\n      }\n    }\n    return _retVal;\n  }\n  isCoordsNotEquals(step) {\n    let _retVal = true;\n    if (step.from.x === step.to.x && step.from.y === step.to.y) {\n      _retVal = false;\n    }\n    return _retVal;\n  }\n  isOneCellStep(step) {\n    // king, pawn\n    return Math.abs(step.to.y - step.from.y) < 2 && Math.abs(step.to.x - step.from.x) < 2;\n  }\n  isLinearStep(step) {\n    // rook, queen\n    return step.from.y === step.to.y || step.from.x === step.to.x;\n  }\n  isDiagonalStep(step) {\n    // bishop, queen\n    return Math.abs(step.to.y - step.from.y) === Math.abs(step.to.x - step.from.x);\n  }\n}","map":{"version":3,"names":["ChessBase","Figure","constructor","name","color","maxX","maxY","isDistancePossible","step","_retVal","Math","abs","to","x","from","y","isStepNotBlocked","isCellToNotBlockedBySameFigure","isCellToNotBlockedByEnemyKing","increaseX","getIncreaseX","increaseY","getIncreaseY","fig","processNext","base","instance","getFigure","figTo","isHitEnemyKingCanBeTested","isCoordsNotEquals","isOneCellStep","isLinearStep","isDiagonalStep"],"sources":["/Users/sumegizoltan/github/_uj/AngularChess/angular-chess/src/app/chess/chess-figure.ts"],"sourcesContent":["import { ChessBase } from \"./chess-base.\";\n\nexport class Figure {\n\n    protected maxX: number;\n    protected maxY: number;\n\n    constructor(public name: string, public color: string, maxX: number, maxY: number){\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    protected isDistancePossible(step: IStep): boolean {\n        let _retVal = false;\n\n        if (Math.abs(step.to!.x - step.from!.x) <= this.maxX && Math.abs(step.to!.y - step.from!.y) <= this.maxY) {\n            _retVal = true;\n        }\n\n        return _retVal;\n    }\n\n    protected isStepNotBlocked(step: IStep): boolean {\n        let _retVal = true;\n\n        if (!this.isCellToNotBlockedBySameFigure(step) || (!this.isCellToNotBlockedByEnemyKing(step))) {\n            _retVal = false;\n        }\n        else {\n            const increaseX = this.getIncreaseX(step);\n            const increaseY = this.getIncreaseY(step);\n            let x: number = step.from!.x;\n            let y: number = step.from!.y;\n            let fig: IFigure | null = null;\n            let processNext: boolean = true;\n            const base = ChessBase.instance;\n\n            while(_retVal && processNext) {\n                x += increaseX;\n                y += increaseY;\n                if (step.to!.x === x && step.to!.y === y) {\n                    processNext = false;\n                }\n                else {\n                    fig = base.getFigure(x, y);\n                    if (fig) {\n                        processNext = false;\n                        _retVal = false;\n                    }\n                } \n            }\n        }\n\n        return _retVal;\n    }\n\n    protected getIncreaseX(step: IStep): number {\n        return (step.to!.x > step.from!.x) ? 1 : (step.to!.x === step.from!.x) ? 0 : -1;\n    }\n\n    protected getIncreaseY(step: IStep): number {\n        return (step.to!.y > step.from!.y) ? 1 : (step.to!.y === step.from!.y) ? 0 : -1;\n    }\n\n    protected isCellToNotBlockedBySameFigure(step: IStep): boolean {\n        let _retVal = true;\n        const figTo = ChessBase.instance.getFigure(step.to!.x, step.to!.y);\n\n        if (figTo && figTo.color === this.color){ \n            _retVal = false;\n        }\n\n        return _retVal;\n    }\n\n    protected isCellToNotBlockedByEnemyKing(step: IStep): boolean {\n        let _retVal = true;\n        const base = ChessBase.instance;\n\n        if (!(base.isHitEnemyKingCanBeTested || this.name === 'pawn')) {\n            const figTo = base.getFigure(step.to!.x, step.to!.y);\n\n            if (figTo && (figTo.color !== this.color) && (figTo.name === 'king')){ \n                _retVal = false;\n            }\n        }\n\n        return _retVal;\n    }\n\n    protected isCoordsNotEquals(step: IStep): boolean {\n        let _retVal = true;\n\n        if (step.from!.x === step.to!.x && step.from!.y === step.to!.y) {\n            _retVal = false;\n        }\n\n        return _retVal;\n    }\n\n    protected isOneCellStep(step: IStep): boolean {\n        // king, pawn\n        \n        return ((Math.abs(step.to!.y - step.from!.y) < 2) && (Math.abs(step.to!.x - step.from!.x) < 2));\n    }\n\n    protected isLinearStep(step: IStep): boolean {\n        // rook, queen\n\n        return (step.from!.y === step.to!.y || step.from!.x === step.to!.x);\n    }\n\n    protected isDiagonalStep(step: IStep): boolean {\n        // bishop, queen\n\n        return (Math.abs(step.to!.y - step.from!.y) === Math.abs(step.to!.x - step.from!.x));\n    }\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}