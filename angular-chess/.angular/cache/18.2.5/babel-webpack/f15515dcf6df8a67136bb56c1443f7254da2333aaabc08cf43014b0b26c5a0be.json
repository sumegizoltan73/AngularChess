{"ast":null,"code":"import { ChessEvents } from './chess.events';\nimport { ChessFactory } from './chess.factory';\n// Singleton class for IBoard items, and events\nexport class ChessBase {\n  static {\n    this.lock = false;\n  }\n  get board() {\n    return this.isVirtualizeBoard ? this._virtualboard : this._board;\n  }\n  set board(value) {\n    if (this.isVirtualizeBoard) {\n      this._virtualboard = value;\n    } else {\n      this._board = value;\n    }\n  }\n  constructor() {\n    this.revertFigureBuffer = null;\n    this.prisonerRemoved = false;\n    this.checkFiguresWithCell = [];\n    this.isVirtualizeBoard = false;\n    this._board = [];\n    this._virtualboard = []; // for check (etc.) detection with virtual steps\n    this.enPassant = null;\n    this.whitePromotionList = [];\n    this.blackPromotionList = [];\n    this.isPawnPromotionWhite = false;\n    this.isPawnPromotionBlack = false;\n    this.isCheckToWhite = false;\n    this.isCheckToBlack = false;\n    this.isCheckMateToWhite = false;\n    this.isCheckMateToBlack = false;\n    this.isWhiteResigned = false;\n    this.isBlackResigned = false;\n    this.isLoaderVisible = false;\n    this.isHitEnemyKingCanBeTested = false;\n    this.isTestInProgress = false;\n    this.events = new ChessEvents();\n  }\n  static get instance() {\n    if (ChessBase._instance == null) {\n      if (!ChessBase.lock) {\n        ChessBase.lock = true;\n        if (ChessBase._instance == null) {\n          ChessBase._instance = new ChessBase();\n        }\n        ChessBase.lock = false;\n      }\n    }\n    return ChessBase._instance;\n  }\n  getFigure(x, y) {\n    const cell = this.board.find(function (el) {\n      return el.x === x && el.y === y;\n    });\n    return cell && cell.figure ? cell.figure : null;\n  }\n  stepFromRemote(step, enPassant) {\n    const fig = this.getFigure(step.from.x, step.from.y);\n    if (this.enPassant) {\n      if (fig && fig.name === 'pawn' && step.to.x === this.enPassant.to.x && step.to.y === this.enPassant.to.y) {\n        // remove prisoner\n        this.removePrisoner();\n      }\n      // en passant just in the next step\n      this.enPassant = null;\n    }\n    this.step(step);\n    if (enPassant) {\n      this.enPassant = enPassant;\n    }\n  }\n  stepAwayIfPossible(step) {\n    this.isLoaderVisible = true;\n    this.isHitEnemyKingCanBeTested = false;\n    const fig = this.getFigure(step.from.x, step.from.y);\n    const isPossible = fig?.isStepPossible(step);\n    let strike = false;\n    if (isPossible) {\n      if (this.enPassant) {\n        if (fig && fig.name === 'pawn' && step.to.x === this.enPassant.to.x && step.to.y === this.enPassant.to.y) {\n          // remove prisoner\n          this.removePrisoner();\n          strike = true;\n        }\n        // en passant just in the next step\n        this.enPassant = null;\n      }\n      let arg = this.stateAfterStep(step);\n      const strikeInStep = this.step(step);\n      strike = strike || strikeInStep;\n      if (arg && arg.state === 'castling' && !this.isCheckToKing(fig.color)) {\n        // castling is not possible in chess\n        this.step(arg.additionalStep);\n      } else if (arg && arg.state === 'en_passant_position') {\n        this.enPassant = arg.enPassant;\n      } else if (arg && arg.state === 'pawn_promotion') {\n        if (fig && fig.color === 'white') {\n          this.isPawnPromotionWhite = true;\n        } else {\n          this.isPawnPromotionBlack = true;\n        }\n      }\n      try {\n        // if stay in check then revert, and throw stepillegal\n        this.isHitEnemyKingCanBeTested = true;\n        this.testCheck(fig.color, true);\n        // if errorCode == 0 (no_error)\n        if (fig.color === 'white') {\n          this.isCheckToWhite = false;\n        } else {\n          this.isCheckToBlack = false;\n        }\n        this.isHitEnemyKingCanBeTested = false;\n        this.isLoaderVisible = false;\n        if (!arg) arg = {};\n        arg['color'] = fig?.color;\n        arg['step'] = step;\n        arg['strike'] = strike;\n        arg['fig'] = fig?.name;\n        this.events.emit('stepFinished', arg);\n      } catch (ex) {\n        this.isHitEnemyKingCanBeTested = false;\n        // if errorCode == 1 (stay_in_check)\n        this.revertStep(step);\n        this.isLoaderVisible = false;\n        this.events.emit('stepIllegal', null);\n      }\n    } else {\n      this.isLoaderVisible = false;\n      this.events.emit('stepIllegal', null);\n    }\n  }\n  stateAfterStep(step) {\n    // check | castling | en_passant_position | pawn_promotion | null\n    let _retVal = null;\n    const figFrom = this.getFigure(step.from.x, step.from.y);\n    // is castling?\n    if (figFrom?.name == 'rook' && step.from.y === step.to.y && (step.from.y === 0 && figFrom.color === 'black' || step.from.y === 7 && figFrom.color === 'white')) {\n      const xOfKing = step.from.x < step.to.x ? step.to.x + 1 : step.to.x - 1;\n      const figToMaybeKing = this.getFigure(xOfKing, step.to.y);\n      if (figToMaybeKing && figToMaybeKing.name === 'king') {\n        if (figToMaybeKing.isOrigPosition({\n          from: {\n            x: xOfKing,\n            y: step.from.y\n          },\n          to: null\n        })) {\n          const xOfKingTo = step.from.x < step.to.x ? step.to.x - 1 : step.to.x + 1;\n          _retVal = {\n            state: 'castling',\n            additionalStep: {\n              from: {\n                x: xOfKing,\n                y: step.from.y\n              },\n              to: {\n                x: xOfKingTo,\n                y: step.from.y\n              }\n            }\n          };\n        }\n      }\n    }\n    if (figFrom?.name === 'pawn') {\n      if (figFrom.isMovedToEnPassantPosition(step)) {\n        // en_passant_position\n        const offsetY = step.to.y > step.from.y ? -1 : 1;\n        _retVal = {\n          state: 'en_passant_position',\n          enPassant: {\n            prisoner: {\n              x: step.to.x,\n              y: step.to.y\n            },\n            to: {\n              x: step.to.x,\n              y: step.to.y + offsetY\n            }\n          }\n        };\n      } else if (figFrom.color === 'white' && step.to.y === 0 && this.whitePromotionList.length > 0 || figFrom.color === 'black' && step.to.y === 7 && this.blackPromotionList.length > 0) {\n        // pawn promotion\n        _retVal = {\n          state: 'pawn_promotion'\n        };\n      }\n    }\n    return _retVal;\n  }\n  convertPawn(name, color, step, i) {\n    if (color === 'white') {\n      this.isPawnPromotionWhite = false;\n      this.whitePromotionList.splice(i, 1);\n    } else {\n      this.isPawnPromotionBlack = false;\n      this.blackPromotionList.splice(i, 1);\n    }\n    this.removeFigure(step.to.x, step.to.y);\n    ChessFactory.createFigure(name, color, step.to.x, step.to.y);\n    this.events.emit('promotionFinished', null);\n  }\n  convertPawnFromRemote(name, color, step) {\n    this.removeFigure(step.to.x, step.to.y);\n    ChessFactory.createFigure(name, color, step.to.x, step.to.y);\n  }\n  testCheckForRemote(color) {\n    this.testCheck(color, false, true, false);\n  }\n  processCombinatedTests(color) {\n    this.isTestInProgress = true;\n    this.isLoaderVisible = true;\n    this.isHitEnemyKingCanBeTested = true;\n    this.testCheck(color, false, true, true);\n    const isCheck = color === 'white' ? this.isCheckToWhite : this.isCheckToBlack;\n    if (isCheck) {\n      // can step away || can block || can hit (if one figure)   \n      let checkmate = true;\n      let testCase = ['can_step_away', 'can_block', 'can_hit'];\n      for (let i = 0; i < testCase.length; i++) {\n        const element = testCase[i];\n        switch (element) {\n          case 'can_step_away':\n            checkmate = !this.canStepAway(color);\n            break;\n          case 'can_block':\n            checkmate = !this.canBlock(color);\n            break;\n          case 'can_hit':\n            checkmate = !this.canHit(color);\n            break;\n          default:\n            break;\n        }\n        if (!checkmate) {\n          break;\n        }\n      }\n      this.clearTestVariables();\n      if (checkmate) {\n        this.isCheckMateToWhite = color === 'white';\n        this.isCheckMateToBlack = color === 'black';\n        this.events.emit('checkmate', null);\n      }\n    } else {\n      // TODO: stalemate\n      // TODO: dead position\n      this.clearTestVariables();\n    }\n  }\n  getKingWithCell(color) {\n    const cell = this.board.find(function (el) {\n      return el.figure?.color === color && el.figure.name === 'king';\n    });\n    return cell;\n  }\n  resign(color) {\n    if (color === 'white') {\n      this.isWhiteResigned = true;\n    } else {\n      this.isBlackResigned = true;\n    }\n    this.events.emit('resign', null);\n  }\n  canStepAway(color) {\n    let _retVal = false;\n    const cell = this.getKingWithCell(color);\n    const from = {\n      x: cell.x,\n      y: cell.y\n    };\n    const arr = cell.figure.getRange(cell.x, cell.y);\n    for (let i = 0; i < arr.length; i++) {\n      const element = arr[i];\n      const step = {\n        from: from,\n        to: {\n          x: element.x,\n          y: element.y\n        }\n      };\n      if (cell.figure.isStepPossible(step)) {\n        this.prepareVirtualBoard(step, cell.figure);\n        try {\n          this.testCheck(color, true, false, false);\n          _retVal = true;\n          break;\n        } catch (ex) {\n          _retVal = false;\n        }\n      }\n    }\n    this.isHitEnemyKingCanBeTested = false;\n    this.isVirtualizeBoard = false;\n    return _retVal;\n  }\n  canBlock(color) {\n    let _retVal = false;\n    if (this.checkFiguresWithCell.length < 2) {\n      const attackerCell = this.checkFiguresWithCell[0];\n      const cell = this.getKingWithCell(color);\n      if (attackerCell.figure?.name !== 'knight' && (Math.abs(attackerCell.x - cell.x) > 1 || Math.abs(attackerCell.y - cell.y) > 1)) {\n        const defenseZone = this.getDefenseZone(cell, attackerCell);\n        for (let i = 0; i < this.board.length; i++) {\n          const element = this.board[i];\n          if (element.figure?.color === color && element.figure.name !== 'king') {\n            const from = {\n              x: element.x,\n              y: element.y\n            };\n            for (let j = 0; j < defenseZone.length; j++) {\n              const dz = defenseZone[j];\n              const step = {\n                from: from,\n                to: {\n                  x: dz.x,\n                  y: dz.y\n                }\n              };\n              if (element.figure.isStepPossible(step)) {\n                this.prepareVirtualBoard(step, element.figure);\n                try {\n                  this.testCheck(color, true, false, false);\n                  _retVal = true;\n                  break;\n                } catch (ex) {\n                  _retVal = false;\n                  this.isVirtualizeBoard = false;\n                }\n              }\n            }\n            if (_retVal) {\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.isHitEnemyKingCanBeTested = false;\n    this.isVirtualizeBoard = false;\n    return _retVal;\n  }\n  canHit(color) {\n    let _retVal = false;\n    if (this.checkFiguresWithCell.length < 2) {\n      const attackerCell = this.checkFiguresWithCell[0];\n      const cell = this.getKingWithCell(color);\n      for (let i = 0; i < this.board.length; i++) {\n        const element = this.board[i];\n        if (element.figure?.color === color) {\n          const from = {\n            x: element.x,\n            y: element.y\n          };\n          const step = {\n            from: from,\n            to: {\n              x: attackerCell.x,\n              y: attackerCell.y\n            }\n          };\n          if (element.figure.isStepPossible(step)) {\n            this.prepareVirtualBoard(step, element.figure);\n            try {\n              this.testCheck(color, true, false, false);\n              _retVal = true;\n              break;\n            } catch (ex) {\n              _retVal = false;\n              this.isVirtualizeBoard = false;\n            }\n          }\n          if (_retVal) {\n            break;\n          }\n        }\n      }\n    }\n    this.isHitEnemyKingCanBeTested = false;\n    this.isVirtualizeBoard = false;\n    return _retVal;\n  }\n  prepareVirtualBoard(step, fig) {\n    // if possible -> copy to virtual, step in virtual, testCheck(virtual)\n    this.isVirtualizeBoard = true;\n    this._virtualboard = this._board.slice();\n    this.removeFigure(step.from.x, step.from.y);\n    this.removeFigure(step.to.x, step.to.y);\n    this._virtualboard.push({\n      x: step.to.x,\n      y: step.to.y,\n      figure: fig\n    });\n    this.isHitEnemyKingCanBeTested = true;\n  }\n  getDefenseZone(cell1, cell2) {\n    let _retVal = [];\n    const lengthX = Math.abs(cell2.x - cell1.x);\n    const lengthY = Math.abs(cell2.y - cell1.y);\n    const j = lengthX >= lengthY ? lengthX : lengthY;\n    const increaseX = lengthX > 0 ? (cell2.x - cell1.x) / lengthX : 0;\n    const increaseY = lengthY > 0 ? (cell2.y - cell1.y) / lengthY : 0;\n    for (let i = 1; i < j; i++) {\n      _retVal.push({\n        x: cell1.x + i * increaseX,\n        y: cell1.y + i * increaseY\n      });\n    }\n    return _retVal;\n  }\n  clearTestVariables() {\n    this.isTestInProgress = false;\n    this.isLoaderVisible = false;\n    this.isHitEnemyKingCanBeTested = false;\n  }\n  revertStep(step) {\n    const fig = this.getFigure(step.to.x, step.to.y);\n    this.removeFigure(step.to.x, step.to.y);\n    this.board.push({\n      x: step.from.x,\n      y: step.from.y,\n      figure: fig\n    });\n    if (this.revertFigureBuffer) {\n      this.board.push({\n        x: this.revertFigureBuffer.x,\n        y: this.revertFigureBuffer.y,\n        figure: this.revertFigureBuffer.figure\n      });\n      if (this.revertFigureBuffer.figure?.name !== 'pawn') {\n        let i = -1;\n        const arr = this.revertFigureBuffer.figure?.color === 'white' ? this.whitePromotionList : this.blackPromotionList;\n        for (let j = 0; j < arr.length; j++) {\n          const element = arr[j];\n          if (element === this.revertFigureBuffer.figure?.name) {\n            i = j;\n            break;\n          }\n        }\n        if (this.revertFigureBuffer.figure?.color === 'white') {\n          this.whitePromotionList.splice(i, 1);\n        } else {\n          this.blackPromotionList.splice(i, 1);\n        }\n      }\n      this.prisonerRemoved = false;\n      this.revertFigureBuffer = null;\n    }\n  }\n  testCheck(color, throwOnCheck, setVariables, saveFigures) {\n    let isCheck = false;\n    const kingWithCell = this.getKingWithCell(color);\n    const stepForCheck = {\n      from: null,\n      to: {\n        x: kingWithCell.x,\n        y: kingWithCell.y\n      }\n    };\n    if (saveFigures === true) {\n      this.checkFiguresWithCell = [];\n    }\n    for (let i = 0; i < this.board.length; i++) {\n      const element = this.board[i];\n      if (element.figure?.color !== color && element.figure?.name !== 'king') {\n        const step = {\n          from: {\n            x: element.x,\n            y: element.y\n          },\n          to: stepForCheck.to\n        };\n        const isCheckFromFigure = element.figure.isStepPossible(step);\n        isCheck = isCheck || isCheckFromFigure;\n        if (isCheckFromFigure && saveFigures !== true) {\n          break;\n        } else if (isCheckFromFigure && saveFigures === true) {\n          this.checkFiguresWithCell.push(element);\n        }\n      }\n    }\n    if (isCheck) {\n      if (setVariables === true) {\n        this.isCheckToWhite = color === 'white';\n        this.isCheckToBlack = color === 'black';\n      }\n      if (throwOnCheck === true) {\n        throw new Error('Check occured!');\n      }\n    } else {\n      if (setVariables === true) {\n        this.isCheckToWhite = color === 'white' ? false : this.isCheckToWhite;\n        this.isCheckToBlack = color === 'black' ? false : this.isCheckToBlack;\n      }\n    }\n  }\n  isCheckToKing(color) {\n    return color === 'white' ? this.isCheckToWhite : this.isCheckToBlack;\n  }\n  removePrisoner() {\n    const figTo = this.getFigure(this.enPassant.prisoner.x, this.enPassant.prisoner.y);\n    if (figTo) {\n      this.revertFigureBuffer = {\n        x: this.enPassant.prisoner.x,\n        y: this.enPassant.prisoner.y,\n        figure: figTo\n      };\n      this.removeFigure(this.enPassant.prisoner.x, this.enPassant.prisoner.y);\n      this.prisonerRemoved = true;\n    }\n  }\n  step(step) {\n    let _retVal = false;\n    const figTo = this.getFigure(step.to.x, step.to.y);\n    if (figTo) {\n      this.revertFigureBuffer = {\n        x: step.to.x,\n        y: step.to.y,\n        figure: figTo\n      };\n      this.removeFigure(step.to.x, step.to.y);\n      _retVal = true;\n      if (figTo.name !== 'pawn') {\n        if (figTo.color === 'white') {\n          this.whitePromotionList.push(figTo.name);\n        } else {\n          this.blackPromotionList.push(figTo.name);\n        }\n      }\n    } else if (this.prisonerRemoved) {\n      this.prisonerRemoved = false;\n    } else {\n      this.revertFigureBuffer = null;\n    }\n    const fig = this.getFigure(step.from.x, step.from.y);\n    if (fig?.name === 'king') {\n      fig.isMoved = true;\n    }\n    this.board.push({\n      x: step.to.x,\n      y: step.to.y,\n      figure: fig\n    });\n    this.removeFigure(step.from.x, step.from.y);\n    return _retVal;\n  }\n  removeFigure(x, y) {\n    const cell = this.board.find(function (el) {\n      return el.x === x && el.y === y;\n    });\n    if (cell) {\n      const index = this.board.indexOf(cell);\n      this.board.splice(index, 1);\n    }\n  }\n}","map":{"version":3,"names":["ChessEvents","ChessFactory","ChessBase","lock","board","isVirtualizeBoard","_virtualboard","_board","value","constructor","revertFigureBuffer","prisonerRemoved","checkFiguresWithCell","enPassant","whitePromotionList","blackPromotionList","isPawnPromotionWhite","isPawnPromotionBlack","isCheckToWhite","isCheckToBlack","isCheckMateToWhite","isCheckMateToBlack","isWhiteResigned","isBlackResigned","isLoaderVisible","isHitEnemyKingCanBeTested","isTestInProgress","events","instance","_instance","getFigure","x","y","cell","find","el","figure","stepFromRemote","step","fig","from","name","to","removePrisoner","stepAwayIfPossible","isPossible","isStepPossible","strike","arg","stateAfterStep","strikeInStep","state","isCheckToKing","color","additionalStep","testCheck","emit","ex","revertStep","_retVal","figFrom","xOfKing","figToMaybeKing","isOrigPosition","xOfKingTo","isMovedToEnPassantPosition","offsetY","prisoner","length","convertPawn","i","splice","removeFigure","createFigure","convertPawnFromRemote","testCheckForRemote","processCombinatedTests","isCheck","checkmate","testCase","element","canStepAway","canBlock","canHit","clearTestVariables","getKingWithCell","resign","arr","getRange","prepareVirtualBoard","attackerCell","Math","abs","defenseZone","getDefenseZone","j","dz","slice","push","cell1","cell2","lengthX","lengthY","increaseX","increaseY","throwOnCheck","setVariables","saveFigures","kingWithCell","stepForCheck","isCheckFromFigure","Error","figTo","isMoved","index","indexOf"],"sources":["/Users/sumegizoltan/github/_uj/AngularChess/angular-chess/src/app/chess/chess-base..ts"],"sourcesContent":["import { FigureKing } from './chess-figure-king';\nimport { FigurePawn } from './chess-figure-pawn';\nimport { ChessEvents } from './chess.events'\nimport { ChessFactory } from './chess.factory';\n\n// Singleton class for IBoard items, and events\nexport class ChessBase {\n    private static lock: boolean = false;  \n    private static _instance?: ChessBase;\n\n    private revertFigureBuffer: ICell | null = null;\n    private prisonerRemoved: boolean = false;\n    private checkFiguresWithCell: ICell[] = [];\n    private isVirtualizeBoard: boolean = false;\n    private _board: ICell[] = [];\n    private _virtualboard: ICell[] = [];     // for check (etc.) detection with virtual steps\n\n    events: ChessEvents;\n    \n    enPassant: any = null;\n    whitePromotionList: string[] = [];\n    blackPromotionList: string[] = [];\n    isPawnPromotionWhite: boolean = false;\n    isPawnPromotionBlack: boolean = false;\n    isCheckToWhite: boolean = false;\n    isCheckToBlack: boolean = false;\n    isCheckMateToWhite: boolean = false;\n    isCheckMateToBlack: boolean = false;\n    isWhiteResigned: boolean = false;\n    isBlackResigned: boolean = false;\n    isLoaderVisible: boolean = false;\n    isHitEnemyKingCanBeTested: boolean = false;\n    isTestInProgress: boolean = false;\n\n    get board(): ICell[] {\n        return (this.isVirtualizeBoard) ? this._virtualboard : this._board;\n    }\n    set board(value: ICell[]) {\n        if (this.isVirtualizeBoard) {\n            this._virtualboard = value;\n        }\n        else {\n            this._board = value;\n        }\n    }\n\n    constructor(){\n        this.events = new ChessEvents();\n    }\n\n    public static get instance(): ChessBase {\n        if (ChessBase._instance == null) {  \n            if (!ChessBase.lock) {  \n                ChessBase.lock = true;\n                if (ChessBase._instance == null) {  \n                    ChessBase._instance = new ChessBase();  \n                }  \n                ChessBase.lock = false;\n            }  \n        }  \n        return ChessBase._instance as ChessBase;\n    } \n\n    getFigure(x: number, y: number): IFigure | null {\n        const cell = this.board.find(function (el) {\n            return el.x === x &&\n                el.y === (y);\n        });\n    \n        return (cell && cell.figure)? cell.figure : null;\n    }\n\n    stepFromRemote(step: IStep, enPassant: any): void {\n        const fig = this.getFigure(step.from!.x, step.from!.y);\n        if (this.enPassant) {\n            if (fig && fig.name === 'pawn'\n                && step.to!.x === this.enPassant.to.x\n                && step.to!.y === this.enPassant.to.y) {\n                // remove prisoner\n                this.removePrisoner();\n            }\n            // en passant just in the next step\n            this.enPassant = null;\n        }\n        this.step(step);\n\n        if (enPassant) {\n            this.enPassant = enPassant;\n        }\n    }\n\n    stepAwayIfPossible(step: IStep): void {\n        this.isLoaderVisible = true;\n        this.isHitEnemyKingCanBeTested = false;\n\n        const fig = this.getFigure(step.from!.x, step.from!.y);\n        const isPossible = fig?.isStepPossible(step);\n        let strike = false;\n\n        if (isPossible) {\n            if (this.enPassant) {\n                if (fig && fig.name === 'pawn'\n                    && step.to!.x === this.enPassant.to.x\n                    && step.to!.y === this.enPassant.to.y) {\n                    // remove prisoner\n                    this.removePrisoner();\n                    strike = true;\n                }\n                // en passant just in the next step\n                this.enPassant = null;\n            }\n\n            let arg = this.stateAfterStep(step);\n\n            const strikeInStep = this.step(step);\n            strike = strike || strikeInStep;\n\n            if (arg && arg.state === 'castling' && (!this.isCheckToKing(fig!.color))) {\n                // castling is not possible in chess\n                this.step(arg.additionalStep);\n            }\n            else if (arg && arg.state === 'en_passant_position') {\n                this.enPassant = arg.enPassant;\n            }\n            else if (arg && arg.state === 'pawn_promotion') {\n                if (fig && fig.color === 'white') {\n                    this.isPawnPromotionWhite = true;\n                }\n                else {\n                    this.isPawnPromotionBlack = true;\n                }\n            }\n\n            try {\n                // if stay in check then revert, and throw stepillegal\n                this.isHitEnemyKingCanBeTested = true;\n                this.testCheck(fig!.color, true);\n\n                // if errorCode == 0 (no_error)\n                if (fig!.color === 'white') {\n                    this.isCheckToWhite = false;\n                }\n                else {\n                    this.isCheckToBlack = false;\n                }\n                this.isHitEnemyKingCanBeTested = false;\n                this.isLoaderVisible = false;\n                if (!arg) arg = {};\n                arg['color'] = fig?.color;\n                arg['step'] = step;\n                arg['strike'] = strike;\n                arg['fig'] = fig?.name;\n                this.events.emit('stepFinished', arg);\n            }\n            catch (ex) {\n                this.isHitEnemyKingCanBeTested = false;\n\n                // if errorCode == 1 (stay_in_check)\n                this.revertStep(step);\n                this.isLoaderVisible = false;\n                this.events.emit('stepIllegal', null);\n            }\n        }\n        else {\n            this.isLoaderVisible = false;\n            this.events.emit('stepIllegal', null);\n        }\n    }\n\n    stateAfterStep(step: IStep): any {\n        // check | castling | en_passant_position | pawn_promotion | null\n        let _retVal = null;\n        const figFrom = this.getFigure(step.from!.x, step.from!.y);\n        \n        // is castling?\n        if (figFrom?.name == 'rook' && step.from!.y === step.to!.y \n                && ((step.from!.y === 0 && figFrom.color === 'black') || (step.from!.y === 7  && figFrom.color === 'white'))) {\n            const xOfKing = (step.from!.x < step.to!.x) ? step.to!.x + 1 : step.to!.x - 1;\n            const figToMaybeKing = this.getFigure(xOfKing, step.to!.y);\n            if (figToMaybeKing && figToMaybeKing.name === 'king') {\n                if ((<FigureKing> figToMaybeKing).isOrigPosition({ from: { x: xOfKing, y: step.from!.y }, to: null })) {\n                    const xOfKingTo = (step.from!.x < step.to!.x) ? step.to!.x - 1 : step.to!.x + 1;\n                    _retVal = { \n                        state: 'castling', \n                        additionalStep: { \n                            from: { x: xOfKing, y: step.from!.y }, \n                            to: { x: xOfKingTo, y: step.from!.y }\n                        } \n                    };\n                }\n            }\n        }\n\n        if (figFrom?.name === 'pawn') {\n            if ((<FigurePawn> figFrom).isMovedToEnPassantPosition(step)) {\n                // en_passant_position\n                const offsetY = (step.to!.y > step.from!.y) ? -1 : 1;\n                _retVal = { \n                    state: 'en_passant_position', \n                    enPassant: { \n                        prisoner: { x: step.to!.x, y: step.to!.y }, \n                        to: { x: step.to!.x, y: step.to!.y + offsetY }\n                    } \n                };\n            }\n            else if ((figFrom.color === 'white' && step.to!.y === 0 && this.whitePromotionList.length > 0)\n                    || figFrom.color === 'black' && step.to!.y === 7 && this.blackPromotionList.length > 0) {\n                // pawn promotion\n                _retVal = { \n                    state: 'pawn_promotion'\n                };\n            }\n        }\n\n        return _retVal;\n    }\n\n    convertPawn(name: string, color: string, step: IStep, i: number): void {\n        if (color === 'white') {\n            this.isPawnPromotionWhite = false;\n            this.whitePromotionList.splice(i, 1);\n        }\n        else {\n            this.isPawnPromotionBlack = false;\n            this.blackPromotionList.splice(i, 1);\n        }\n        \n        this.removeFigure(step.to!.x, step.to!.y);\n        ChessFactory.createFigure(name, color, step.to!.x, step.to!.y);\n\n        this.events.emit('promotionFinished', null);\n    }\n\n    convertPawnFromRemote(name: string, color: string, step: IStep): void {\n        this.removeFigure(step.to!.x, step.to!.y);\n        ChessFactory.createFigure(name, color, step.to!.x, step.to!.y);\n    }\n\n    testCheckForRemote(color: string): void {\n        this.testCheck(color, false, true, false);\n    }\n\n    processCombinatedTests(color: string): void {\n        this.isTestInProgress = true;\n        this.isLoaderVisible = true;\n        this.isHitEnemyKingCanBeTested = true;\n\n        this.testCheck(color, false, true, true);\n\n        const isCheck: boolean = (color === 'white') ? this.isCheckToWhite : this.isCheckToBlack;\n        \n        if (isCheck) {\n            // can step away || can block || can hit (if one figure)   \n            let checkmate : boolean = true;\n            let testCase: string[] = ['can_step_away', 'can_block', 'can_hit'];\n            \n            for (let i = 0; i < testCase.length; i++) {\n                const element = testCase[i];\n                \n                switch (element) {\n                    case 'can_step_away':\n                        checkmate = !this.canStepAway(color);\n                        break;\n\n                    case 'can_block':\n                        checkmate = !this.canBlock(color);\n                        break;\n\n                    case 'can_hit':\n                        checkmate = !this.canHit(color);\n                        break;\n                \n                    default:\n                        break;\n                }\n\n                if (!checkmate) {\n                    break;\n                }\n            }\n\n            this.clearTestVariables();\n\n            if (checkmate) {\n                this.isCheckMateToWhite = (color === 'white');\n                this.isCheckMateToBlack = (color === 'black');\n                this.events.emit('checkmate', null);\n            }\n        }\n        else {\n            // TODO: stalemate\n\n            // TODO: dead position\n\n            this.clearTestVariables();\n        }\n    }\n\n    getKingWithCell(color: string): ICell {\n        const cell = this.board.find(function (el) {\n            return el.figure?.color === color &&\n                el.figure.name === 'king';\n        });\n    \n        return cell as ICell;\n    }\n\n    resign(color: string): void {\n        if (color === 'white') {\n            this.isWhiteResigned = true;\n        }\n        else {\n            this.isBlackResigned = true;\n        }\n\n        this.events.emit('resign', null);\n    }\n\n    private canStepAway(color: string): boolean {\n        let _retVal = false;\n\n        const cell = this.getKingWithCell(color);\n        const from: ICord = { x: cell.x, y: cell.y }; \n        const arr: ICord[] = (<FigureKing> cell.figure).getRange(cell.x, cell.y);\n        for (let i = 0; i < arr.length; i++) {\n            const element = arr[i];\n            const step: IStep = {\n                from: from,\n                to: { x: element.x, y: element.y }\n            }; \n            if (cell.figure!.isStepPossible(step)) {\n                this.prepareVirtualBoard(step, cell.figure!);\n\n                try {\n                    this.testCheck(color, true, false, false);\n\n                    _retVal = true;\n                    break;\n                }\n                catch (ex) {\n                    _retVal = false;\n                }\n\n            }\n        }\n\n        this.isHitEnemyKingCanBeTested = false;\n        this.isVirtualizeBoard = false;\n\n        return _retVal;\n    }\n\n    private canBlock(color: string): boolean {\n        let _retVal = false;\n\n        if (this.checkFiguresWithCell.length < 2) {\n            const attackerCell = this.checkFiguresWithCell[0];\n            const cell = this.getKingWithCell(color);\n            if (attackerCell.figure?.name !== 'knight'\n                && (Math.abs(attackerCell.x - cell.x) > 1\n                    || Math.abs(attackerCell.y - cell.y) > 1)) {\n                const defenseZone = this.getDefenseZone(cell, attackerCell);\n\n                for (let i = 0; i < this.board.length; i++) {\n                    const element = this.board[i];\n                    \n                    if (element.figure?.color === color && element.figure.name !== 'king'){\n                        const from: ICord = { x: element.x, y: element.y }; \n\n                        for (let j = 0; j < defenseZone.length; j++) {\n                            const dz = defenseZone[j];\n                            const step: IStep = {\n                                from: from,\n                                to: { x: dz.x, y: dz.y }\n                            }; \n                            if (element.figure!.isStepPossible(step)) {\n                                this.prepareVirtualBoard(step, element.figure);\n\n                                try {\n                                    this.testCheck(color, true, false, false);\n\n                                    _retVal = true;\n                                    break;\n                                }\n                                catch (ex) {\n                                    _retVal = false;\n                                    this.isVirtualizeBoard = false;\n                                }\n                            }\n                        }\n\n                        if (_retVal) {\n                            break;\n                        }\n                    }\n                }\n\n            }\n        }\n\n        this.isHitEnemyKingCanBeTested = false;\n        this.isVirtualizeBoard = false;\n\n        return _retVal;\n    }\n\n    private canHit(color: string): boolean {\n        let _retVal = false;\n\n        if (this.checkFiguresWithCell.length < 2) {\n            const attackerCell = this.checkFiguresWithCell[0];\n            const cell = this.getKingWithCell(color);\n            \n            for (let i = 0; i < this.board.length; i++) {\n                const element = this.board[i];\n                \n                if (element.figure?.color === color){\n                    const from: ICord = { x: element.x, y: element.y }; \n                    const step: IStep = {\n                        from: from,\n                        to: { x: attackerCell.x, y: attackerCell.y }\n                    }; \n                    if (element.figure!.isStepPossible(step)) {\n                        this.prepareVirtualBoard(step, element.figure);\n\n                        try {\n                            this.testCheck(color, true, false, false);\n\n                            _retVal = true;\n                            break;\n                        }\n                        catch (ex) {\n                            _retVal = false;\n                            this.isVirtualizeBoard = false;\n                        }\n                    }\n\n                    if (_retVal) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        this.isHitEnemyKingCanBeTested = false;\n        this.isVirtualizeBoard = false;\n\n        return _retVal;\n    }\n\n    private prepareVirtualBoard(step: IStep, fig: IFigure): void {\n        // if possible -> copy to virtual, step in virtual, testCheck(virtual)\n        this.isVirtualizeBoard = true;\n        this._virtualboard = this._board.slice();\n        this.removeFigure(step.from!.x, step.from!.y);\n        this.removeFigure(step.to!.x, step.to!.y);\n        this._virtualboard.push({\n            x: step.to!.x,\n            y: step.to!.y,\n            figure: fig\n        });\n        this.isHitEnemyKingCanBeTested = true;\n    }\n\n    private getDefenseZone(cell1: ICell, cell2: ICell): ICord[] {\n        let _retVal: ICord[] = [];\n        const lengthX = Math.abs(cell2.x - cell1.x);\n        const lengthY = Math.abs(cell2.y - cell1.y);\n        const j = (lengthX >= lengthY) ? lengthX : lengthY;\n        const increaseX = (lengthX > 0) ? (cell2.x - cell1.x) / lengthX : 0;\n        const increaseY = (lengthY > 0) ? (cell2.y - cell1.y) / lengthY : 0;\n\n        for (let i = 1; i < j; i++) {\n            _retVal.push({ x: cell1.x + (i * increaseX), y: cell1.y + (i * increaseY)});\n        }\n\n        return _retVal;\n    }\n    \n    private clearTestVariables(): void {\n        this.isTestInProgress = false;\n        this.isLoaderVisible = false;\n        this.isHitEnemyKingCanBeTested = false;\n    }\n\n    private revertStep(step: IStep): void {\n        const fig = this.getFigure(step.to!.x, step.to!.y);\n        \n        this.removeFigure(step.to!.x, step.to!.y);\n        this.board.push({\n            x: step.from!.x,\n            y: step.from!.y,\n            figure: fig\n        });\n\n        if (this.revertFigureBuffer) {\n            this.board.push({\n                x: this.revertFigureBuffer.x,\n                y: this.revertFigureBuffer.y,\n                figure: this.revertFigureBuffer.figure\n            });\n\n            if (this.revertFigureBuffer.figure?.name !== 'pawn') {\n                let i = -1;\n                const arr = (this.revertFigureBuffer.figure?.color === 'white') ? this.whitePromotionList : this.blackPromotionList;\n                for (let j = 0; j < arr.length; j++) {\n                    const element = arr[j];\n                    if (element === this.revertFigureBuffer.figure?.name) {\n                        i = j;\n                        break;\n                    }\n                }\n\n                if (this.revertFigureBuffer.figure?.color === 'white') {\n                    this.whitePromotionList.splice(i, 1);\n                }\n                else {\n                    this.blackPromotionList.splice(i, 1);\n                }\n            }\n\n            this.prisonerRemoved = false;\n            this.revertFigureBuffer = null;\n        }\n    }\n    \n    private testCheck(color: string, throwOnCheck?: boolean, setVariables?: boolean, saveFigures?: boolean): void {\n        let isCheck: boolean = false;\n        const kingWithCell: ICell = this.getKingWithCell(color);\n        const stepForCheck: IStep = {\n            from: null,\n            to: {\n                x: kingWithCell.x,\n                y: kingWithCell.y\n            }\n        };\n\n        if (saveFigures === true) {\n            this.checkFiguresWithCell = [];\n        }\n\n        for (let i = 0; i < this.board.length; i++) {\n            const element = this.board[i];\n            \n            if (element.figure?.color !== color && element.figure?.name !== 'king') {\n                const step = {\n                    from: { x: element.x, y: element.y },\n                    to: stepForCheck.to\n                };\n\n                const isCheckFromFigure = element.figure!.isStepPossible(step);\n                isCheck = isCheck || isCheckFromFigure;\n\n                if (isCheckFromFigure && saveFigures !== true) {\n                    break;\n                }\n                else if (isCheckFromFigure && saveFigures === true) {\n                    this.checkFiguresWithCell.push(element);\n                }\n            }\n        }\n\n        if (isCheck) {\n            if (setVariables === true) {\n                this.isCheckToWhite = (color === 'white');\n                this.isCheckToBlack = (color === 'black');\n            }\n\n            if (throwOnCheck === true) {\n                throw new Error('Check occured!');\n            }\n        }\n        else {\n            if (setVariables === true) {\n                this.isCheckToWhite = (color === 'white') ? false: this.isCheckToWhite;\n                this.isCheckToBlack = (color === 'black') ? false: this.isCheckToBlack;\n            }\n        }\n    }\n\n    private isCheckToKing(color: string): boolean {\n        return (color === 'white') ? this.isCheckToWhite : this.isCheckToBlack;\n    }\n\n    private removePrisoner(): void {\n        const figTo = this.getFigure(this.enPassant.prisoner.x, this.enPassant.prisoner.y);\n        if (figTo) {\n            this.revertFigureBuffer = {\n                x: this.enPassant.prisoner.x,\n                y: this.enPassant.prisoner.y,\n                figure: figTo\n            };\n            this.removeFigure(this.enPassant.prisoner.x, this.enPassant.prisoner.y);\n            this.prisonerRemoved = true;\n        }\n    }\n\n    private step(step: IStep): boolean {\n        let _retVal = false;\n        const figTo = this.getFigure(step.to!.x, step.to!.y);\n        if (figTo) {\n            this.revertFigureBuffer = {\n                x: step.to!.x,\n                y: step.to!.y,\n                figure: figTo\n            };\n            this.removeFigure(step.to!.x, step.to!.y);\n            _retVal = true;\n\n            if (figTo.name !== 'pawn') {\n                if (figTo.color === 'white') {\n                    this.whitePromotionList.push(figTo.name);\n                }\n                else {\n                    this.blackPromotionList.push(figTo.name);\n                }\n            }\n        }\n        else if (this.prisonerRemoved) {\n            this.prisonerRemoved = false;\n        }\n        else {\n            this.revertFigureBuffer = null;\n        }\n\n        const fig = this.getFigure(step.from!.x, step.from!.y);\n        \n        if (fig?.name === 'king') {\n            (<FigureKing> fig).isMoved = true;\n        }\n\n        this.board.push({\n            x: step.to!.x,\n            y: step.to!.y,\n            figure: fig\n        });\n        this.removeFigure(step.from!.x, step.from!.y);\n\n        return _retVal;\n    }\n\n    private removeFigure(x: number, y: number): void {\n        const cell = this.board.find(function (el) {\n            return el.x === x &&\n                el.y === (y);\n        });\n        if (cell) {\n            const index = this.board.indexOf(cell);\n            this.board.splice(index, 1);\n        }\n    }\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}