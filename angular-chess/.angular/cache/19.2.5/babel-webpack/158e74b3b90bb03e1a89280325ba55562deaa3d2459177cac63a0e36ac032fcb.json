{"ast":null,"code":"import { ChessEvents } from './chess.events';\nimport { ChessFactory } from './chess.factory';\n// Singleton class for IBoard items, and events\nexport let ChessBase = /*#__PURE__*/(() => {\n  class ChessBase {\n    static {\n      this.lock = false;\n    }\n    get board() {\n      return this.isVirtualizeBoard ? this._virtualboard : this._board;\n    }\n    set board(value) {\n      if (this.isVirtualizeBoard) {\n        this._virtualboard = value;\n      } else {\n        this._board = value;\n      }\n    }\n    constructor() {\n      this.revertFigureBuffer = null;\n      this.prisonerRemoved = false;\n      this.checkFiguresWithCell = [];\n      this.isVirtualizeBoard = false;\n      this._board = [];\n      this._virtualboard = []; // for check (etc.) detection with virtual steps\n      this.enPassant = null;\n      this.whitePromotionList = [];\n      this.blackPromotionList = [];\n      this.isPawnPromotionWhite = false;\n      this.isPawnPromotionBlack = false;\n      this.isCheckToWhite = false;\n      this.isCheckToBlack = false;\n      this.isCheckMateToWhite = false;\n      this.isCheckMateToBlack = false;\n      this.isWhiteResigned = false;\n      this.isBlackResigned = false;\n      this.isLoaderVisible = false;\n      this.isHitEnemyKingCanBeTested = false;\n      this.isTestInProgress = false;\n      this.events = new ChessEvents();\n    }\n    static get instance() {\n      if (ChessBase._instance == null) {\n        if (!ChessBase.lock) {\n          ChessBase.lock = true;\n          if (ChessBase._instance == null) {\n            ChessBase._instance = new ChessBase();\n          }\n          ChessBase.lock = false;\n        }\n      }\n      return ChessBase._instance;\n    }\n    getFigure(x, y) {\n      const cell = this.board.find(function (el) {\n        return el.x === x && el.y === y;\n      });\n      return cell && cell.figure ? cell.figure : null;\n    }\n    stepFromRemote(step, enPassant) {\n      const fig = this.getFigure(step.from.x, step.from.y);\n      if (this.enPassant) {\n        if (fig && fig.name === 'pawn' && step.to.x === this.enPassant.to.x && step.to.y === this.enPassant.to.y) {\n          // remove prisoner\n          this.removePrisoner();\n        }\n        // en passant just in the next step\n        this.enPassant = null;\n      }\n      this.step(step);\n      if (enPassant) {\n        this.enPassant = enPassant;\n      }\n    }\n    stepAwayIfPossible(step) {\n      this.isLoaderVisible = true;\n      this.isHitEnemyKingCanBeTested = false;\n      const fig = this.getFigure(step.from.x, step.from.y);\n      const isPossible = fig?.isStepPossible(step);\n      let strike = false;\n      if (isPossible) {\n        if (this.enPassant) {\n          if (fig && fig.name === 'pawn' && step.to.x === this.enPassant.to.x && step.to.y === this.enPassant.to.y) {\n            // remove prisoner\n            this.removePrisoner();\n            strike = true;\n          }\n          // en passant just in the next step\n          this.enPassant = null;\n        }\n        let arg = this.stateAfterStep(step);\n        const strikeInStep = this.step(step);\n        strike = strike || strikeInStep;\n        if (arg && arg.state === 'castling' && !this.isCheckToKing(fig.color)) {\n          // castling is not possible in chess\n          this.step(arg.additionalStep);\n        } else if (arg && arg.state === 'en_passant_position') {\n          this.enPassant = arg.enPassant;\n        } else if (arg && arg.state === 'pawn_promotion') {\n          if (fig && fig.color === 'white') {\n            this.isPawnPromotionWhite = true;\n          } else {\n            this.isPawnPromotionBlack = true;\n          }\n        }\n        try {\n          // if stay in check then revert, and throw stepillegal\n          this.isHitEnemyKingCanBeTested = true;\n          this.testCheck(fig.color, true);\n          // if errorCode == 0 (no_error)\n          if (fig.color === 'white') {\n            this.isCheckToWhite = false;\n          } else {\n            this.isCheckToBlack = false;\n          }\n          this.isHitEnemyKingCanBeTested = false;\n          this.isLoaderVisible = false;\n          if (!arg) arg = {};\n          arg['color'] = fig?.color;\n          arg['step'] = step;\n          arg['strike'] = strike;\n          arg['fig'] = fig?.name;\n          this.events.emit('stepFinished', arg);\n        } catch (ex) {\n          this.isHitEnemyKingCanBeTested = false;\n          // if errorCode == 1 (stay_in_check)\n          this.revertStep(step);\n          this.isLoaderVisible = false;\n          this.events.emit('stepIllegal', null);\n        }\n      } else {\n        this.isLoaderVisible = false;\n        this.events.emit('stepIllegal', null);\n      }\n    }\n    stateAfterStep(step) {\n      // check | castling | en_passant_position | pawn_promotion | null\n      let _retVal = null;\n      const figFrom = this.getFigure(step.from.x, step.from.y);\n      // is castling?\n      if (figFrom?.name == 'rook' && step.from.y === step.to.y && (step.from.y === 0 && figFrom.color === 'black' || step.from.y === 7 && figFrom.color === 'white')) {\n        const xOfKing = step.from.x < step.to.x ? step.to.x + 1 : step.to.x - 1;\n        const figToMaybeKing = this.getFigure(xOfKing, step.to.y);\n        if (figToMaybeKing && figToMaybeKing.name === 'king') {\n          if (figToMaybeKing.isOrigPosition({\n            from: {\n              x: xOfKing,\n              y: step.from.y\n            },\n            to: null\n          })) {\n            const xOfKingTo = step.from.x < step.to.x ? step.to.x - 1 : step.to.x + 1;\n            _retVal = {\n              state: 'castling',\n              additionalStep: {\n                from: {\n                  x: xOfKing,\n                  y: step.from.y\n                },\n                to: {\n                  x: xOfKingTo,\n                  y: step.from.y\n                }\n              }\n            };\n          }\n        }\n      }\n      if (figFrom?.name === 'pawn') {\n        if (figFrom.isMovedToEnPassantPosition(step)) {\n          // en_passant_position\n          const offsetY = step.to.y > step.from.y ? -1 : 1;\n          _retVal = {\n            state: 'en_passant_position',\n            enPassant: {\n              prisoner: {\n                x: step.to.x,\n                y: step.to.y\n              },\n              to: {\n                x: step.to.x,\n                y: step.to.y + offsetY\n              }\n            }\n          };\n        } else if (figFrom.color === 'white' && step.to.y === 0 && this.whitePromotionList.length > 0 || figFrom.color === 'black' && step.to.y === 7 && this.blackPromotionList.length > 0) {\n          // pawn promotion\n          _retVal = {\n            state: 'pawn_promotion'\n          };\n        }\n      }\n      return _retVal;\n    }\n    convertPawn(name, color, step, i) {\n      if (color === 'white') {\n        this.isPawnPromotionWhite = false;\n        this.whitePromotionList.splice(i, 1);\n      } else {\n        this.isPawnPromotionBlack = false;\n        this.blackPromotionList.splice(i, 1);\n      }\n      this.removeFigure(step.to.x, step.to.y);\n      ChessFactory.createFigure(name, color, step.to.x, step.to.y);\n      this.events.emit('promotionFinished', null);\n    }\n    convertPawnFromRemote(name, color, step) {\n      this.removeFigure(step.to.x, step.to.y);\n      ChessFactory.createFigure(name, color, step.to.x, step.to.y);\n    }\n    testCheckForRemote(color) {\n      this.testCheck(color, false, true, false);\n    }\n    processCombinatedTests(color) {\n      this.isTestInProgress = true;\n      this.isLoaderVisible = true;\n      this.isHitEnemyKingCanBeTested = true;\n      this.testCheck(color, false, true, true);\n      const isCheck = color === 'white' ? this.isCheckToWhite : this.isCheckToBlack;\n      if (isCheck) {\n        // can step away || can block || can hit (if one figure)   \n        let checkmate = true;\n        let testCase = ['can_step_away', 'can_block', 'can_hit'];\n        for (let i = 0; i < testCase.length; i++) {\n          const element = testCase[i];\n          switch (element) {\n            case 'can_step_away':\n              checkmate = !this.canStepAway(color);\n              break;\n            case 'can_block':\n              checkmate = !this.canBlock(color);\n              break;\n            case 'can_hit':\n              checkmate = !this.canHit(color);\n              break;\n            default:\n              break;\n          }\n          if (!checkmate) {\n            break;\n          }\n        }\n        this.clearTestVariables();\n        if (checkmate) {\n          this.isCheckMateToWhite = color === 'white';\n          this.isCheckMateToBlack = color === 'black';\n          this.events.emit('checkmate', null);\n        }\n      } else {\n        // TODO: stalemate\n        // TODO: dead position\n        this.clearTestVariables();\n      }\n    }\n    getKingWithCell(color) {\n      const cell = this.board.find(function (el) {\n        return el.figure?.color === color && el.figure.name === 'king';\n      });\n      return cell;\n    }\n    resign(color) {\n      if (color === 'white') {\n        this.isWhiteResigned = true;\n      } else {\n        this.isBlackResigned = true;\n      }\n      this.events.emit('resign', null);\n    }\n    canStepAway(color) {\n      let _retVal = false;\n      const cell = this.getKingWithCell(color);\n      const from = {\n        x: cell.x,\n        y: cell.y\n      };\n      const arr = cell.figure.getRange(cell.x, cell.y);\n      for (let i = 0; i < arr.length; i++) {\n        const element = arr[i];\n        const step = {\n          from: from,\n          to: {\n            x: element.x,\n            y: element.y\n          }\n        };\n        if (cell.figure.isStepPossible(step)) {\n          this.prepareVirtualBoard(step, cell.figure);\n          try {\n            this.testCheck(color, true, false, false);\n            _retVal = true;\n            break;\n          } catch (ex) {\n            _retVal = false;\n          }\n        }\n      }\n      this.isHitEnemyKingCanBeTested = false;\n      this.isVirtualizeBoard = false;\n      return _retVal;\n    }\n    canBlock(color) {\n      let _retVal = false;\n      if (this.checkFiguresWithCell.length < 2) {\n        const attackerCell = this.checkFiguresWithCell[0];\n        const cell = this.getKingWithCell(color);\n        if (attackerCell.figure?.name !== 'knight' && (Math.abs(attackerCell.x - cell.x) > 1 || Math.abs(attackerCell.y - cell.y) > 1)) {\n          const defenseZone = this.getDefenseZone(cell, attackerCell);\n          for (let i = 0; i < this.board.length; i++) {\n            const element = this.board[i];\n            if (element.figure?.color === color && element.figure.name !== 'king') {\n              const from = {\n                x: element.x,\n                y: element.y\n              };\n              for (let j = 0; j < defenseZone.length; j++) {\n                const dz = defenseZone[j];\n                const step = {\n                  from: from,\n                  to: {\n                    x: dz.x,\n                    y: dz.y\n                  }\n                };\n                if (element.figure.isStepPossible(step)) {\n                  this.prepareVirtualBoard(step, element.figure);\n                  try {\n                    this.testCheck(color, true, false, false);\n                    _retVal = true;\n                    break;\n                  } catch (ex) {\n                    _retVal = false;\n                    this.isVirtualizeBoard = false;\n                  }\n                }\n              }\n              if (_retVal) {\n                break;\n              }\n            }\n          }\n        }\n      }\n      this.isHitEnemyKingCanBeTested = false;\n      this.isVirtualizeBoard = false;\n      return _retVal;\n    }\n    canHit(color) {\n      let _retVal = false;\n      if (this.checkFiguresWithCell.length < 2) {\n        const attackerCell = this.checkFiguresWithCell[0];\n        const cell = this.getKingWithCell(color);\n        for (let i = 0; i < this.board.length; i++) {\n          const element = this.board[i];\n          if (element.figure?.color === color) {\n            const from = {\n              x: element.x,\n              y: element.y\n            };\n            const step = {\n              from: from,\n              to: {\n                x: attackerCell.x,\n                y: attackerCell.y\n              }\n            };\n            if (element.figure.isStepPossible(step)) {\n              this.prepareVirtualBoard(step, element.figure);\n              try {\n                this.testCheck(color, true, false, false);\n                _retVal = true;\n                break;\n              } catch (ex) {\n                _retVal = false;\n                this.isVirtualizeBoard = false;\n              }\n            }\n            if (_retVal) {\n              break;\n            }\n          }\n        }\n      }\n      this.isHitEnemyKingCanBeTested = false;\n      this.isVirtualizeBoard = false;\n      return _retVal;\n    }\n    prepareVirtualBoard(step, fig) {\n      // if possible -> copy to virtual, step in virtual, testCheck(virtual)\n      this.isVirtualizeBoard = true;\n      this._virtualboard = this._board.slice();\n      this.removeFigure(step.from.x, step.from.y);\n      this.removeFigure(step.to.x, step.to.y);\n      this._virtualboard.push({\n        x: step.to.x,\n        y: step.to.y,\n        figure: fig\n      });\n      this.isHitEnemyKingCanBeTested = true;\n    }\n    getDefenseZone(cell1, cell2) {\n      let _retVal = [];\n      const lengthX = Math.abs(cell2.x - cell1.x);\n      const lengthY = Math.abs(cell2.y - cell1.y);\n      const j = lengthX >= lengthY ? lengthX : lengthY;\n      const increaseX = lengthX > 0 ? (cell2.x - cell1.x) / lengthX : 0;\n      const increaseY = lengthY > 0 ? (cell2.y - cell1.y) / lengthY : 0;\n      for (let i = 1; i < j; i++) {\n        _retVal.push({\n          x: cell1.x + i * increaseX,\n          y: cell1.y + i * increaseY\n        });\n      }\n      return _retVal;\n    }\n    clearTestVariables() {\n      this.isTestInProgress = false;\n      this.isLoaderVisible = false;\n      this.isHitEnemyKingCanBeTested = false;\n    }\n    revertStep(step) {\n      const fig = this.getFigure(step.to.x, step.to.y);\n      this.removeFigure(step.to.x, step.to.y);\n      this.board.push({\n        x: step.from.x,\n        y: step.from.y,\n        figure: fig\n      });\n      if (this.revertFigureBuffer) {\n        this.board.push({\n          x: this.revertFigureBuffer.x,\n          y: this.revertFigureBuffer.y,\n          figure: this.revertFigureBuffer.figure\n        });\n        if (this.revertFigureBuffer.figure?.name !== 'pawn') {\n          let i = -1;\n          const arr = this.revertFigureBuffer.figure?.color === 'white' ? this.whitePromotionList : this.blackPromotionList;\n          for (let j = 0; j < arr.length; j++) {\n            const element = arr[j];\n            if (element === this.revertFigureBuffer.figure?.name) {\n              i = j;\n              break;\n            }\n          }\n          if (this.revertFigureBuffer.figure?.color === 'white') {\n            this.whitePromotionList.splice(i, 1);\n          } else {\n            this.blackPromotionList.splice(i, 1);\n          }\n        }\n        this.prisonerRemoved = false;\n        this.revertFigureBuffer = null;\n      }\n    }\n    testCheck(color, throwOnCheck, setVariables, saveFigures) {\n      let isCheck = false;\n      const kingWithCell = this.getKingWithCell(color);\n      const stepForCheck = {\n        from: null,\n        to: {\n          x: kingWithCell.x,\n          y: kingWithCell.y\n        }\n      };\n      if (saveFigures === true) {\n        this.checkFiguresWithCell = [];\n      }\n      for (let i = 0; i < this.board.length; i++) {\n        const element = this.board[i];\n        if (element.figure?.color !== color && element.figure?.name !== 'king') {\n          const step = {\n            from: {\n              x: element.x,\n              y: element.y\n            },\n            to: stepForCheck.to\n          };\n          const isCheckFromFigure = element.figure.isStepPossible(step);\n          isCheck = isCheck || isCheckFromFigure;\n          if (isCheckFromFigure && saveFigures !== true) {\n            break;\n          } else if (isCheckFromFigure && saveFigures === true) {\n            this.checkFiguresWithCell.push(element);\n          }\n        }\n      }\n      if (isCheck) {\n        if (setVariables === true) {\n          this.isCheckToWhite = color === 'white';\n          this.isCheckToBlack = color === 'black';\n        }\n        if (throwOnCheck === true) {\n          throw new Error('Check occured!');\n        }\n      } else {\n        if (setVariables === true) {\n          this.isCheckToWhite = color === 'white' ? false : this.isCheckToWhite;\n          this.isCheckToBlack = color === 'black' ? false : this.isCheckToBlack;\n        }\n      }\n    }\n    isCheckToKing(color) {\n      return color === 'white' ? this.isCheckToWhite : this.isCheckToBlack;\n    }\n    removePrisoner() {\n      const figTo = this.getFigure(this.enPassant.prisoner.x, this.enPassant.prisoner.y);\n      if (figTo) {\n        this.revertFigureBuffer = {\n          x: this.enPassant.prisoner.x,\n          y: this.enPassant.prisoner.y,\n          figure: figTo\n        };\n        this.removeFigure(this.enPassant.prisoner.x, this.enPassant.prisoner.y);\n        this.prisonerRemoved = true;\n      }\n    }\n    step(step) {\n      let _retVal = false;\n      const figTo = this.getFigure(step.to.x, step.to.y);\n      if (figTo) {\n        this.revertFigureBuffer = {\n          x: step.to.x,\n          y: step.to.y,\n          figure: figTo\n        };\n        this.removeFigure(step.to.x, step.to.y);\n        _retVal = true;\n        if (figTo.name !== 'pawn') {\n          if (figTo.color === 'white') {\n            this.whitePromotionList.push(figTo.name);\n          } else {\n            this.blackPromotionList.push(figTo.name);\n          }\n        }\n      } else if (this.prisonerRemoved) {\n        this.prisonerRemoved = false;\n      } else {\n        this.revertFigureBuffer = null;\n      }\n      const fig = this.getFigure(step.from.x, step.from.y);\n      if (fig?.name === 'king') {\n        fig.isMoved = true;\n      }\n      this.board.push({\n        x: step.to.x,\n        y: step.to.y,\n        figure: fig\n      });\n      this.removeFigure(step.from.x, step.from.y);\n      return _retVal;\n    }\n    removeFigure(x, y) {\n      const cell = this.board.find(function (el) {\n        return el.x === x && el.y === y;\n      });\n      if (cell) {\n        const index = this.board.indexOf(cell);\n        this.board.splice(index, 1);\n      }\n    }\n  }\n  return ChessBase;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}