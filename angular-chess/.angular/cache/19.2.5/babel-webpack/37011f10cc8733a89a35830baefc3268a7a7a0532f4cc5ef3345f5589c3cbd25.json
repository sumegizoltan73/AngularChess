{"ast":null,"code":"import { ChessBase } from \"./chess-base.\";\nexport class Figure {\n  constructor(name, color, maxX, maxY) {\n    this.name = name;\n    this.color = color;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  isDistancePossible(step) {\n    let _retVal = false;\n    if (Math.abs(step.to.x - step.from.x) <= this.maxX && Math.abs(step.to.y - step.from.y) <= this.maxY) {\n      _retVal = true;\n    }\n    return _retVal;\n  }\n  isStepNotBlocked(step) {\n    let _retVal = true;\n    if (!this.isCellToNotBlockedBySameFigure(step) || !this.isCellToNotBlockedByEnemyKing(step)) {\n      _retVal = false;\n    } else {\n      const increaseX = this.getIncreaseX(step);\n      const increaseY = this.getIncreaseY(step);\n      let x = step.from.x;\n      let y = step.from.y;\n      let fig = null;\n      let processNext = true;\n      const base = ChessBase.instance;\n      while (_retVal && processNext) {\n        x += increaseX;\n        y += increaseY;\n        if (step.to.x === x && step.to.y === y) {\n          processNext = false;\n        } else {\n          fig = base.getFigure(x, y);\n          if (fig) {\n            processNext = false;\n            _retVal = false;\n          }\n        }\n      }\n    }\n    return _retVal;\n  }\n  getIncreaseX(step) {\n    return step.to.x > step.from.x ? 1 : step.to.x === step.from.x ? 0 : -1;\n  }\n  getIncreaseY(step) {\n    return step.to.y > step.from.y ? 1 : step.to.y === step.from.y ? 0 : -1;\n  }\n  isCellToNotBlockedBySameFigure(step) {\n    let _retVal = true;\n    const figTo = ChessBase.instance.getFigure(step.to.x, step.to.y);\n    if (figTo && figTo.color === this.color) {\n      _retVal = false;\n    }\n    return _retVal;\n  }\n  isCellToNotBlockedByEnemyKing(step) {\n    let _retVal = true;\n    const base = ChessBase.instance;\n    if (!(base.isHitEnemyKingCanBeTested || this.name === 'pawn')) {\n      const figTo = base.getFigure(step.to.x, step.to.y);\n      if (figTo && figTo.color !== this.color && figTo.name === 'king') {\n        _retVal = false;\n      }\n    }\n    return _retVal;\n  }\n  isCoordsNotEquals(step) {\n    let _retVal = true;\n    if (step.from.x === step.to.x && step.from.y === step.to.y) {\n      _retVal = false;\n    }\n    return _retVal;\n  }\n  isOneCellStep(step) {\n    // king, pawn\n    return Math.abs(step.to.y - step.from.y) < 2 && Math.abs(step.to.x - step.from.x) < 2;\n  }\n  isLinearStep(step) {\n    // rook, queen\n    return step.from.y === step.to.y || step.from.x === step.to.x;\n  }\n  isDiagonalStep(step) {\n    // bishop, queen\n    return Math.abs(step.to.y - step.from.y) === Math.abs(step.to.x - step.from.x);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}